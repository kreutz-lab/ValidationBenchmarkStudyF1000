#' bs_DA_plotFunctions
#'
#' Making plots from DA_dataframe such as hist of p-values or heatmap for the number of significant features. 
#'
#'
#' @param df data.frame obtained from bs_DA2dataframe()
#' @param plotType (check code about possiblities)
#'  "histP"
#'  "ROC"
#'  "ROC_Sens_alpha"
#'  "ROC_Spec_alpha"
#'  "heatmap"
#'  ...
#' @param plotArg options dependening on plotType (check code)
#' @param rowOrdering NULL [default] (as it is, no clustering, no sorting)
#'    "sorted" alphabetically sorted
#'
#' @return out ggplot object which can be plotted by print(out)
#' 
#' @examples
#' 
#' df <- readRDS("../Results/2023_07_07-DA_tests_Analysis_2000_df.RDS")
#' 
#' bs_DA_plotFunctions(df) # making several plots
#' bs_DA_plotFunctions(df,folder="2023_11_12-DA_plots") # several plots & saving
#' 
#' bs_DA_plotFunctions(df[grep("metaSPARSimNonReg_1",df$dataset),]) # making several plots only for a single simulation
#' 
#' bs_DA_plotFunctions(df,"histP","p_value")
#' 
#' df <- data.frame(df,significant=df$p_value<=0.05)
# 'dfPlot <- df[df$dataset=="original",]
# '
#' heat <- bs_DA_plotFunctions(dfPlot, plotType="heatmap", plotArg ="original, p <= 0.05") # clustered rows
#' heat
#' bs_DA_plotFunctions(dfPlot, plotType="heatmap", plotArg ="original, p <= 0.05", rowOrdering = NULL) # no clustering
#' bs_DA_plotFunctions(df[df$dataset=="metaSPARSim_0",], plotType="heatmap", plotArg = list(label="template cluster order"), rowOrdering = heat$desiredOrder) # same order as "original"
#' bs_DA_plotFunctions(dfPlot, plotType="heatmapScaled", plotArg = list(label="original, p <= 0.05")) # scaled
#' bs_DA_plotFunctions(dfPlot, plotType="heatmapRanks", plotArg = list(label="original, p <= 0.05")) # ranks
#' 
#' d <- readRDS("../Results/2023_07_13-DA_tests_Analysis_metasparsimNoreg_2000.RDS")
#' d <- msb.subset(d,20:21)
#' d <- bs_addTruth(d)
#' df <- bs_DA2dataFrame(d,addTruth = T)
#' 
#' bs_DA_plotFunctions(df,"ROC")
#' 
#' # Faster option:
#' out2 <- bs_DA_plotFunctions(df,"ROC_Sens_alpha")
#' out3 <- bs_DA_plotFunctions(df,"ROC_Spec_alpha")
#'
#' # Slower option:
#' bs_DA_plotFunctions(df,"Sens_vs_alpha")
#' bs_DA_plotFunctions(df,"PPV_vs_alpha")
#' 
#' @seealso \code{\link{anotherFunction}}
#' @keywords aKeywordSuchAsBenchmarking
#' @export

bs_DA_plotFunctions <- function(df,plotType=NULL,plotArg="",rowOrdering="hclust",folder=NULL,useNearingNames=F){
  
  df$test <- bs_replaceTestNames(df$test)
  
  isSingle <- function(Test){
    return(ifelse(!grepl("<-",Test),c(Combi="solid"),c(noCombi="dashed")))
  }
  
  if(useNearingNames)
    df <- bs_renameDataAccordingToNearing(df,colName = "project")
  
  if(is.null(plotType)){
    
    # make all possible plots:
    
    tmp <- bs_DA_plotFunctions(df,"histP","p_value",folder=folder)
    if(!is.null(folder)){
      dir.create(folder,showWarnings = F)
      save(df,tmp,folder, file=paste0(folder,"/histP.Rdata"))
      pdf(file=paste0(folder,"/histP.pdf"),height=12,width=12)
      print(tmp)
      dev.off()
    }
    else 
      print(tmp)
    
    
    
    tmp <- bs_DA_plotFunctions(df,"histP_singleDataset","p_value",folder=folder)
    if(!is.null(folder)){
      dir.create(folder,showWarnings = F)
      save(df, tmp, folder, file=paste0(folder,"/histP_byDataSet.Rdata"))
      pdf(file=paste0(folder,"/histP_byDataSet.pdf"),height=12,width=12)
      print(tmp)
      dev.off()
    }
    else 
      print(tmp)
    
    tmp <- bs_DA_plotFunctions(df,"ROC",folder=folder)
    if(!is.null(folder)){
      save(df, tmp, folder, file=paste0(folder,"/ROC.Rdata"))
      pdf(file=paste0(folder,"/ROC.pdf"),width=10,height=10)
      print(tmp)
      dev.off()
    }
    else
      print(tmp)
    
    tmp <- bs_DA_plotFunctions(df,"ROC_Sens_alpha",folder=folder)
    if(!is.null(folder)){
      save(df, tmp, folder, file=paste0(folder,"/Sens_vs_alpha.Rdata"))
      pdf(file=paste0(folder,"/Sens_vs_alpha.pdf"),width=10,height=10)
      print(tmp)
      dev.off()
    }
    else
      print(tmp)
    
    tmp <- bs_DA_plotFunctions(df,"ROC_Spec_alpha",folder=folder)
    if(!is.null(folder)){
      save(df, tmp, folder, file=paste0(folder,"/ROC_Spec_alpha.Rdata"))
      pdf(file=paste0(folder,"/ROC_Spec_alpha.pdf"),width=10,height=10)
      print(tmp)
      dev.off()
    }
    else
      print(tmp)
    
    tmp <- bs_DA_plotFunctions(df,"OverlapHist",folder=folder) 
    if(!is.null(folder)){
      save(df, tmp, folder, file=paste0(folder,"/OverlapHist.Rdata"))
      pdf(file=paste0(folder,"/OverlapHist.pdf"),width=8,height=16)
      print(tmp)
      dev.off()
    }
    else 
      print(tmp)
    
    if(length(unique(df$project))>1){ # Heatmaps make only sense if more than 1 project:
      if(! "significant" %in% names(df)){
        print("bs_DA_plotFunctions: No column df$signficiant found: Is now generated by significant=df$p_adjusted<=0.05. ")
        df <- data.frame(df,significant=df$p_adjusted<=0.05)
      }
      tmp <- bs_DA_plotFunctions(df, plotType="heatmap", plotArg = list(label=paste0(plotArg, ", rows clustered")),folder=folder) # clustered rows
      if(!is.null(folder)){
        save(df, tmp, plotArg, folder, file=paste0(folder,"/heatmapClustered.Rdata"))
        pdf(file=paste0(folder,"/heatmapClustered.pdf"),width = 8, height=6)
        print(tmp)
        dev.off()
      }
      else 
        print(tmp)
      tmp <- bs_DA_plotFunctions(df, plotType="heatmap", plotArg = list(label=paste0(plotArg, ", no clustering")), rowOrdering = "sorted",folder=folder)  # no clustering
      if(!is.null(folder)){
        save(df, tmp, plotArg, folder, file=paste0(folder,"/heatmap.Rdata"))
        pdf(file=paste0(folder,"/heatmap.pdf"),width = 8, height=6)
        print(tmp)
        dev.off()
      }
      else 
        print(tmp)
      tmp <- bs_DA_plotFunctions(df, plotType="heatmapScaled", plotArg = list(label=paste0(plotArg, ", scaled & rows clustered")),folder=folder) # scaled
      if(!is.null(folder)){
        save(df, tmp, plotArg, folder, file=paste0(folder,"/heatmapScaled.Rdata"))
        pdf(file=paste0(folder,"/heatmapScaled.pdf"),width = 8, height=6)
        print(tmp)
        dev.off()
      }
      else 
        print(tmp)
      tmp <- bs_DA_plotFunctions(df, plotType="heatmapScaled", plotArg = list(label=paste0(plotArg, ", scaled & sorted")),rowOrdering = "sorted",folder=folder) # scaled
      if(!is.null(folder)){
        save(df, tmp, plotArg, folder, file=paste0(folder,"/heatmapScaledandSorted.Rdata"))
        pdf(file=paste0(folder,"/heatmapScaledandSorted.pdf"),width = 8, height=6)
        print(tmp)
        dev.off()
      }else 
        print(tmp)
      tmp <- bs_DA_plotFunctions(df, plotType="heatmapScaled", plotArg = list(label=paste0(plotArg, ", scaled & sortedNearing")),rowOrdering = "nearing",folder=folder) # scaled
      if(!is.null(folder)){
        save(df, tmp, plotArg, folder, file=paste0(folder,"/heatmapScaledandSorted.Rdata"))
        pdf(file=paste0(folder,"/heatmapScaledandSorted.pdf"))
        print(tmp)
        dev.off()
      }
      
      else 
        print(tmp)
      tmp <- bs_DA_plotFunctions(df, plotType="heatmapRanks", plotArg =list(label=paste0(plotArg, ", ranks & rows clustered")),folder=folder) # ranks
      if(!is.null(folder)){
        save(df, tmp, plotArg, folder, file=paste0(folder,"/heatmapRanks.Rdata"))
        pdf(file=paste0(folder,"/heatmapRanks.pdf"))
        print(tmp)
        dev.off()
      }
      else 
        print(tmp)
    }
    
  }
  
  
  else{ # only a single plot:
    
    print(plotType)
    
    out <- NULL
    desiredOrder <- NULL
    
    df$test <- as.factor(df$test)
    df$project <- as.factor(df$project)
    df$dataset <- as.factor(df$dataset)
    
    # Sensitivity vs. alpha (i.e. vs. FDR-threshold)
    if(plotType=="Sens_vs_alpha" || plotType=="PPV_vs_alpha"){
      
      proj_names <- unique(df$project) # [1:10]
      data.plot.all <- NULL
      for (proj in proj_names) {
        test_names <- unique(df$test)
        it <- 0
        for (tst in test_names) {
          it <- it+1
          # Subset the data for the current project and test:
          project_test_data <- df %>%    #grouped_data replaced by df
            filter(project == proj,test==tst)
          if(nrow(project_test_data)>0){
            # project_test_data <- project_test_data[order(project_test_data$p_adjusted), ]
            # truth_NA <- project_test_data$truth
            # truth_NA[is.na(truth_NA)] <- 0
            # cum <- cumsum(truth_NA)
            # 
            # PPV <- cum/cumsum(!is.na(project_test_data$truth))
            # Sens <- cum/sum(project_test_data$truth,na.rm=T)
            # project_test_data <- data.frame(project_test_data,sensitivity=Sens,PPV=PPV)
            
            # Convert to data.table for faster operations (if it's not already a data.table)
            data.table::setDT(project_test_data)
            # Order by p_adjusted - data.table's setorder is faster and works by reference
            setorder(project_test_data, p_adjusted)
            # Vectorized NA replacement
            if(!"truth" %in% names(project_test_data))
              stop("truth not available, maybe call bs_addTruth(data_to_compare) and then bs_DA2dataFrame(data_to_compare,addTruth = T) before.")
            truth_NA <- data.table::fifelse(is.na(project_test_data$truth), 0, project_test_data$truth)
            # Cumulative sums - these are already vectorized
            cum <- cumsum(truth_NA)
            # Computing Sens and PPV
            PPV <- cum/cumsum(!is.na(project_test_data$truth))
            Sens <- cum/sum(project_test_data$truth, na.rm = TRUE)
            
            # Combine results into the original data.table (efficient modification)
            project_test_data[, c("sensitivity", "PPV") := .(Sens, PPV)]
            if(is.null(data.plot.all))
              data.plot.all <- data.frame(project_test_data,project=proj,Test=tst)
            else
              data.plot.all <- rbind(data.plot.all,data.frame(project_test_data,project=proj,Test=tst))
          }
        }
      }
      my_colors <- bs_colorsTests(data.plot.all$Test)
      #      my_lines <- bs_linesTests(data.plot.all$Test)
      
      if(plotType=="Sens_vs_alpha"){
        out <- ggplot(data.plot.all, aes(x = p_adjusted, y = sensitivity, color = Test)) + # map aesthetics to columns
          geom_line(aes(linetype=isSingle(Test))) +  
          geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black")+
          facet_wrap(~ project) +  # create a panel for each project
          labs(x = "FDR", y = "Sensitivity") +  # label axes
          theme_bw() +  # use a theme with a white background
          theme(strip.text.x = element_text(size = 8),  # adjust facet label size if necessary
                strip.background = element_rect(colour="white", fill="white")) # adjust facet label background
        out <- out + scale_color_manual(values = my_colors) +
          scale_linetype_manual(values = c("solid","dashed")) +
          guides(color = guide_legend(ncol = 1))
      }
      if(plotType=="PPV_vs_alpha"){
        out <- ggplot(data.plot.all, aes(x = p_adjusted, y = PPV, color = Test)) + # map aesthetics to columns
          geom_line(aes(linetype=isSingle(Test))) +  
          facet_wrap(~ project) +  # create a panel for each project
          labs(x = "FDR", y = "PPV") +  # label axes
          theme_bw() +  # use a theme with a white background
          theme(strip.text.x = element_text(size = 8),  # adjust facet label size if necessary
                strip.background = element_rect(colour="white", fill="white")) # adjust facet label background
        out <- out + scale_color_manual(values = my_colors) +
          scale_linetype_manual(values = c("solid","dashed")) +
          guides(color = guide_legend(ncol = 1))
      }
    } # plotType="Sens_vs_alpha"
    
    # ROC curves
    if(plotType=="ROC" || plotType=="ROC_Sens_alpha" || plotType=="ROC_Spec_alpha"){
      if(!"truth" %in% names(df)){
        cat("df$truth not available: plotting ROC curve(s) is omitted.\n")
      }else{ # truth available
        roc_plots <- list()
        
        # Generate ROC plots for each project and test
        proj_names <- unique(df$project)
        data.plot.all <- NULL
        for (proj in proj_names) {
          it <- 0
          roc_curves <- list()
          roc_data <- list()
          test_names <- unique(df$test)
          for (tst in test_names) {
            it <- it+1
            # Subset the data for the current project and test
            project_test_data <- df %>%    #grouped_data replaced by df
              filter(project == proj,test==tst)
            
            # Calculate ROC curve
            if(sum(!is.na(project_test_data$p_value[!is.na(project_test_data$truth)]))>1 && length(unique(project_test_data$truth))>1){
              pvals <- project_test_data$p_value
              pvals[is.na(pvals)] <- 1
              
              roc_curves[[it]] <- pROC::roc(response=project_test_data$truth, 
                                            predictor=pvals, quiet=T,
                                            direction=">")
              roc_data[[it]] <- coords(roc_curves[[it]])
            } else { # DA or truth not available
              roc_data[[it]] <- data.frame(threshold=NA,specificity=NA,sensitivity=NA)
            }
          }
          names(roc_data) <- test_names #neu
          
          data.plot <- bind_rows(roc_data, .id="Test") #neu
          data.plot.all <- rbind(data.plot.all,data.frame(data.plot,project=proj))
        }  
        
        my_colors <- bs_colorsTests(data.plot.all$Test)
        # interpolating sens and spec
        interpolate_metrics <- function(data, targetThreshold=0.05) {
          target_sensitivity <- NA
          target_specificity <- NA
          try(target_sensitivity <- approx(data$threshold, data$sensitivity, xout = targetThreshold, method = "linear")$y)
          try(target_specificity <- approx(data$threshold, data$specificity, xout = targetThreshold, method = "linear")$y)
          return(data.frame(threshold = targetThreshold, sensitivity = target_sensitivity, specificity = target_specificity))
        }
        
        dfTarget <- data.plot.all %>%
          group_by(Test, project) %>%
          do(interpolate_metrics(.)) %>%
          ungroup() 
        cat("For alpha=0.05, the following sens. and spec is achieved:\n")
        
        if(length(proj_names)==1){
          fs <- 12
          if(plotType=="ROC"){
            out <- ggplot(data.plot, aes(1 - specificity, sensitivity, colour = Test))
            out <- out + geom_point(data = dfTarget, aes(x = 1 - specificity, y = sensitivity, fill = Test), shape = 21, size = 3) +  # add points
              geom_vline(xintercept = 0.05, linetype = "solid", color = "gray", size = 1) +  # add vertical line
              geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") 
          }
          else if(plotType=="ROC_Sens_alpha"){
            out <- ggplot(data.plot, aes(threshold, sensitivity, colour = Test)) +
              geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") 
            
          }else if(plotType=="ROC_Spec_alpha"){
            out <- ggplot(data.plot, aes(threshold, specificity, colour = Test)) +
              geom_abline(slope = -1, intercept = 1, linetype = "dashed", color = "black") 
          }
          out <- out + geom_line(aes(linetype=isSingle(Test))) +
            theme_bw()+
            labs(title = proj, subtitle = folder) #+
          out <- out + scale_color_manual(values = my_colors) +
            scale_fill_manual(values = my_colors) +  # map fill to Test
            scale_linetype_manual(values = c("solid","dashed")) +
            guides(color = guide_legend(ncol = 1)) +
            theme(axis.text = element_text(size = fs),  # Adjusts the font size of axis labels
                  axis.title = element_text(size = fs+1),  # Adjusts the font size of axis titles
                  plot.title = element_text(size = fs+2)) +
            scale_x_continuous(labels = percent_format(accuracy = 1)) +  # display x-axis as percentage
            scale_y_continuous(labels = percent_format(accuracy = 1))  # display y-axis as percentage
        }else{
          # Combine ROC plots as subplots in one figure with adjusted font size
          if(length(proj_names)>16)
            fs = 5
          if(length(proj_names)>10)
            fs = 6
          else if(length(proj_names)>4)
            fs = 8
          else if(length(proj_names)>1)
            fs = 10
          else
            fs = 14
          
          if(plotType=="ROC"){
            out <- ggplot(data.plot.all, aes(x = 1 - specificity, y = sensitivity, color = Test))  # map aesthetics to columns
          }
          else if(plotType=="ROC_Sens_alpha")
            out <- ggplot(data.plot.all, aes(x = threshold, y = sensitivity, color = Test))  # map aesthetics to columns
          else if(plotType=="ROC_Spec_alpha")
            out <- ggplot(data.plot.all, aes(x = threshold, y = specificity, color = Test))  # map aesthetics to columns
          
          out <- out +
            geom_line(aes(linetype=isSingle(Test))) +  # use line geometry
            facet_wrap(~ project) +  # create a panel for each project
            theme_bw() +  # use a theme with a white background
            theme(strip.text.x = element_text(size = fs),  # adjust facet label size if necessary
                  strip.background = element_rect(colour="white", fill="white")) # adjust facet label background
          
          out <- out + scale_color_manual(values = my_colors) +
            scale_linetype_manual(values = c("solid","dashed")) +
            guides(color = guide_legend(ncol = 1))
          
        }
        
        # Result data.frame
        # For spec>0.95 sort according to sens, for spec<0.95 sort according to sped:
        rf <- order(dfTarget$specificity+100*as.numeric(dfTarget$specificity>=.95)*dfTarget$sensitivity)
        out$dfTarget <- dfTarget[rf,] # 0.05 dot as data.frame
        
        print(out$dfTarget,n=Inf)
        
      } # else, i.e. truth available
    }
    
    
    # Histogram Barplot for overlap
    if(plotType=="OverlapHist"){
      if(!"significant" %in% names(df) ){
        print("df$signficiant not found: use p_adjusted<=0.05. Calculated df$signficiant beforehand if another criterion is desired.")
        df <- data.frame(df,significant=df$p_adjusted<=0.05)
      }
      dslevs <- unique(df$dataset)
      if(length(dslevs)>1){ # split and call function for each dataset
        out <- list()
        for(id in 1:length(dslevs)){
          dftmp <- df[df$dataset==dslevs[id],]
          out[[id]] <- bs_DA_plotFunctions(dftmp,plotType=plotType,plotArg=plotArg,rowOrdering=rowOrdering,folder=folder)
        }
      }
      else{ # do plotting
        
        df2 <- df[,names(df) %in% c("feature","test","significant")]
        df2 <- pivot_wider(df2,names_from = test, values_from = significant)
        df2 <- select(df2,-feature)
        
        levt <- unique(as.character(df$test))
        for(i in 1:length(levt)){
          # Simple counting:
          #anz <- rowSums(df2[,!names(df2)==levt[i]],na.rm = T) * rowSums(!is.na(df2[,!names(df2)==levt[i]]),na.rm = T) / nrow(df2[,!names(df2)==levt[i]])
          # Adjust for bias occuring when some test yield NA (i.e. strech to range [1,nrow])
          anz <- rowSums(df2[,!names(df2)==levt[i]],na.rm = T) * rowSums(!is.na(df2[,!names(df2)==levt[i]]),na.rm = T) / ncol(df2[,!names(df2)==levt[i]])
          anz[!df2[,levt[i]]] <- NA # count only lines which are significant for levt[i]: exclude FALSE
          anz[is.na(df2[,levt[i]])] <- NA # count only lines which are significant for levt[i]: exclude NA
          if(i==1){
            dfanz <- data.frame(anz)
            names(dfanz) <- levt[i]
          } else{
            dfanz[,levt[i]] <- anz
          }
        }
        
        dfanzL <- dfanz %>% pivot_longer(cols = names(dfanz),
                                         names_to = "test",
                                         values_to = "Overlap")
        
        
        # nTest <- length(unique(df$test))
        # # Bring tests in same order as in Nearing
        # dfanzL$test <- factor(dfanzL$test,levels=c("ALDEx2","ancombc","corncob","DESeq","EdgeR","bs_lefse","limma_voom","limma_voom_TMMwsp","Maaslin2","Maaslin2_rare","metagenomeSeq","bs_ttest_rare.test","bs_wilcox.test","bs_wilcox_rare.test"))
        # out <- ggplot(dfanzL, aes(x = Overlap, fill = test)) +
        #   geom_histogram(aes(y = ..density..), binwidth = .5, position = "dodge") +
        #   facet_wrap( ~ test, nrow = length(unique(dfanzL$test))) +
        #   scale_y_continuous(labels = percent_format(), name = "Percentage") +
        #   scale_x_continuous(breaks = seq(0, nTest, length.out = nTest +
        #                                     1)) +
        #   labs(title = unique(df$dataset), subtitle = folder,
        #        x = "Number of other tests that are also signficant",
        #        y = "Count") +
        #   theme_minimal()+
        #   theme(
        #     legend.text = element_text(size = 5),
        #     strip.text = element_text(size = 20)  # Adjust size as needed
        #   )
        # 
        
        # dfanzL <- dfanzL[!is.na(dfanzL$Overlap),]
        # # Calculate densities
        # dfanzL_density <- dfanzL %>%
        #   group_by(test, Overlap) %>%
        #   summarise(count = n()) %>%
        #   group_by(test) %>%
        #   mutate(density = count / sum(count),
        #          percentage = density * 100) %>%
        #   ungroup()
        
        testLev <- unique(dfanzL$test)
        dfanzL_density <- NULL
        for(test in testLev){
          dftmp <- dfanzL[dfanzL$test==test,]
          tmp <- msb.counts2intDensity(dftmp$Overlap,xs=0:(length(testLev)-1))
          if(!is.null(tmp)){
            dfdens <- tibble(test=rep(test,length(tmp$x)),Overlap=tmp$x, count=tmp$y)
            dfdens <- tibble(dfdens, density=dfdens$count/sum(dfdens$count,na.rm=T))
            dfdens <- tibble(dfdens, percentage=dfdens$density*100)
            if(is.null(dfanzL_density))
              dfanzL_density <- dfdens
            else
              dfanzL_density <- rbind(dfanzL_density,dfdens)
          }
        }
        #        saveRDS(dfanzL_density,file="dfanzL_density.RDS")
        
        nTest <- length(unique(df$test))
        # Bring tests in same order as in Nearing
        levOrder <- intersect(c("ALDEx2","ancombc","corncob","DESeq","EdgeR","bs_lefse","limma_voom","limma_voom_TMMwsp","Maaslin2","Maaslin2_rare","metagenomeSeq","bs_ttest_rare.test","bs_wilcox.test","bs_wilcox_rare.test"),
                              unique(as.character(dfanzL_density$test)))
        dfanzL_density$test <- factor(dfanzL_density$test,levels=levOrder)
        
        ## Add number of significant ones
        testNames = unique(dfanzL_density$test)
        testNames <- testNames[!is.na(testNames)]
        dfanzL_density$anzSig <- array(dim=nrow(dfanzL_density))
        for(oneTest in testNames){
          dfanzL_density$anzSig[oneTest==dfanzL_density$test] <- sum(df2[[as.character(oneTest)]],na.rm=T)
        }
        
        # Plot
        out <- ggplot(dfanzL_density, aes(x = Overlap, y = density, fill = anzSig)) +
          geom_bar(stat = "identity", position = "dodge") +
          facet_wrap(~ test, nrow = length(unique(dfanzL_density$test))) +
          scale_y_continuous(labels = percent_format(), name = "Percentage") +
          scale_x_continuous(breaks = 0:13) +
          labs(title = unique(df$dataset), subtitle = folder,
               x = "Number of other tests that are also significant",
               y = "Percentage") +
          scale_fill_gradientn(
            colors = c("cyan", "navy"),
            values = scales::rescale(c(min(dfanzL_density$anzSig), max(dfanzL_density$anzSig))),
            name = "Significant Calls"
          ) +  # Customize colors and values as needed
          theme_minimal() +
          theme(
            legend.text = element_text(size = 5),
            strip.text = element_text(size = 15)  # Adjust size as needed
          )    
        # my_colors <- bs_colorsTests(dfanzL$test)
        #         out <- out + scale_color_manual(values = my_colors) +
        #   guides(color = guide_legend(ncol = 1))
        
      }
    }
    # PCA of overlap:
    if(plotType=="OverlapPCA"){
      df2 <- df[,names(df) %in% c("feature","test","significant")]
      df2 <- pivot_wider(df2,names_from = test, values_from = significant)
      df2 <- select(df2,-feature)
      
      df2[is.na(df2)] <- FALSE
      jaccard_dist <- vegdist(t(df2), method = "jaccard")
      
      mds <- cmdscale(jaccard_dist, k = 2)
      mds_data <- data.frame(PC1 = mds[, 1], PC2 = mds[, 2],label=names(df2))
      out <- ggplot(data = mds_data, aes(x = PC1, y = PC2)) +
        geom_point() +
        geom_text(aes(label = label), nudge_x = 0.01, nudge_y = 0.01, size = 3) +  # Add labels  labs(x = "PC1", y = "PC2") +
        theme_minimal()
      
      out <- out + scale_color_manual(values = my_colors) +
        guides(color = guide_legend(ncol = 1))
    }
    
    # histogram of p-values, by Project and Test
    if(plotType=="histP"){
      if(is.null(plotArg) || nchar(plotArg)==0)
        stop("histP option requires plotArg, e.g. pvalues as string. All colnames of df are possible: ",paste(colnames(df),sep=", "))
      whichVar <- plotArg
      
      out <- ggplot(df, aes(x = .data[[whichVar]], y = ..density.., fill = dataset)) +
        geom_histogram(binwidth = 0.1, color = "black", position = "dodge") +
        facet_grid(project ~ test, scales = "free") +
        labs(x = "p-value", y = "Rel. frequency [pdf]", subtitle = folder) +
        ggtitle(paste0("Histograms of ",whichVar," by Project and Test")) +
        #scale_x_continuous(limits = c(0, 1)) +
        theme(
          axis.text = element_text(size = 5),    # Adjusts the font size of axis labels
          axis.title = element_text(size = 5),  # Adjusts the font size of axis titles
          strip.text = element_text(size = 8),  # Adjusts the font size of facet labels
          plot.title = element_text(size = 12)   # Adjusts the font size of plot title
        )+
        theme_bw()
    }
    
    
    
    if(plotType=="histP_singleDataset"){
      if(is.null(plotArg))
        stop("histP option requires plotArg, e.g. pvalues as string")
      whichVar <- plotArg
      
      out <- ggplot(df, aes(x = .data[[whichVar]], fill = dataset)) +
        geom_histogram(binwidth = 0.1, color = "black", ) +
        facet_grid(dataset ~ test, scales = "free") +
        labs(x = "p-value", y = "Rel. frequency [pdf]") +
        ggtitle(paste0("Histograms of ",whichVar," by Dataset and Test")) +
        #scale_x_continuous(limits = c(0, 1)) +
        theme(
          axis.text = element_text(size = 5),    # Adjusts the font size of axis labels
          axis.title = element_text(size = 5),  # Adjusts the font size of axis titles
          strip.text = element_text(size = 8),  # Adjusts the font size of facet labels
          plot.title = element_text(size = 12)   # Adjusts the font size of plot title
        )+
        theme_bw()
      
      
    }
    
    
    if(plotType=="heatmap"){
      if(!is.null(plotArg) && "label" %in% names(plotArg))
        label <- plotArg$label
      else
        label <- ""
      
      heatmap_data <- df %>%
        group_by(test,project) %>%
        summarise(num_significant = sum(significant,na.rm=T), 
                  prop_significant = mean(significant,na.rm=T))
      
      if(length(rowOrdering)==1 && rowOrdering=="hclust"){
        desiredOrder <- orderRowsByClustering(heatmap_data,"prop_significant")
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==1 && rowOrdering=="sorted"){
        desiredOrder <- sort(unique(heatmap_data$project), decreasing = T)
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==length(unique(heatmap_data$project)) && length(rowOrdering)>1){
        desiredOrder <- rowOrdering
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      
      # Clipping values of prop_significant to the range [-3.2, 3.2]
      try(heatmap_data$prop_significant <- pmin(pmax(heatmap_data$prop_significant, -3.2), 3.2))
      
      out <- ggplot(heatmap_data, aes(x = test, y = project, fill = prop_significant)) +
        geom_tile() +
        geom_text(aes(label = num_significant), color = "black", size = 2) +
        scale_fill_gradient2(low = "steelblue3", mid="lightyellow", high = "red2",midpoint=0.5,limits=c(0,1)) +
        labs(x = "Differential abundance test", y = "Data set", 
             title = paste0("Significant taxa (",label,")"), subtitle = folder) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
    } 
    
    # Proportions are scaled for each row, i.e. mean=0, std=1, Colobar like in Nearing et. al (unfiltered)
    if(plotType=="heatmapScaled"){
      if(!is.null(plotArg) && "label" %in% names(plotArg))
        label <- plotArg$label
      else
        label <- ""
      
      heatmap_data <- df %>%
        group_by(test,project) %>%
        summarise(num_significant = sum(significant,na.rm=T), 
                  prop_significant = mean(significant,na.rm=T))
      
      heatmap_data$prop_sign_scaled <- scale(heatmap_data$prop_significant)
      
      #colorMin <- quantile(heatmap_data$prop_sign_scaled,.01)  
      #colorMax <- quantile(heatmap_data$prop_sign_scaled,.99)  
      #colorMid <- (colorMax+colorMin)*0.7 # as close as possible to Nearing
      colorMin <- -1.5 # like in Nearing et al, unfiltered
      colorMax <- 3.5 # like in Nearing et al, unfiltered
      colorMid <- 1 # like in Nearing et al, unfiltered
      
      if(length(rowOrdering)==1 && rowOrdering=="hclust"){
        desiredOrder <- orderRowsByClustering(heatmap_data,"prop_sign_scaled")
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==1 && rowOrdering=="sorted"){
        desiredOrder <- sort(unique(heatmap_data$project), decreasing = T)
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==1 && rowOrdering=="nearing"){
        OrderNearing <- c("cdi_schubert", "wood_plastic_kesy","ob_turnbaugh", "ArcticFireSoils", "edd_singh","sed_plastic_hoellein","sw_plastic_frere","seston_plastic_mccormick", "Ji_WTP_DS", "ArcticFreshwaters","GWMC_ASIA_NA", "sw_sed_detender","Chemerin","GWMC_HOT_COLD","Office","ArcticTransects","hiv_noguerajulian","cdi_vincent", "ob_zhu", "ibd_gevers", "Exercise", "Blueberry", "hiv_dinh", "ibd_papa", "glass_plastic_oberbeckmann", "ob_goodrich", "t1d_alkanani", "BISCUIT", "ob_ross", "par_scheperjans", "art_scher", "t1d_mejialeon", "asd_son", "crc_baxter", "MALL", "crc_zeller", "hiv_lozupone", "sed_plastic_rosato")
        desiredOrder <- factor(OrderNearing,levels=OrderNearing)
        heatmap_data$project <- factor(heatmap_data$project,levels=rev(desiredOrder),ordered = T)
        #heatmap_data <- bs_renameDataAccordingToNearing(heatmap_data, colName=project)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==length(unique(heatmap_data$project))){
        desiredOrder <- rowOrdering
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      
      # Clipping values of prop_sign_scaled to the range [colorMin, colorMax]
      try(heatmap_data$prop_sign_scaled <- pmin(pmax(heatmap_data$prop_sign_scaled, colorMin), colorMax))
      out <- ggplot(heatmap_data, aes(x = test, y = project, fill = prop_sign_scaled)) +
        geom_tile() +
        geom_text(aes(label = num_significant), color = "black", size = 2) +
        scale_fill_gradient2(low = "steelblue3", mid="lightyellow", high = "red2",midpoint = colorMid, limits=c(colorMin,colorMax), 
                             name = "% significant [scaled]") +
        labs(x = "Differential abundance test", y = "Data set", 
             title = paste0("Significant taxa (",label,")"), subtitle = folder) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
    } 
    
    # Proportions are scaled for each row, i.e. mean=0, std=1, Colobar like in Nearing et. al (filtered)
    if(plotType=="heatmapScaled2"){
      if(!is.null(plotArg) && "label" %in% names(plotArg))
        label <- plotArg$label
      else
        label <- ""
      
      heatmap_data <- df %>%
        group_by(test,project) %>%
        summarise(num_significant = sum(significant,na.rm=T), 
                  prop_significant = mean(significant,na.rm=T))
      
      heatmap_data$prop_sign_scaled <- scale(heatmap_data$prop_significant)
      
      #colorMin <- quantile(heatmap_data$prop_sign_scaled,.01)  
      #colorMax <- quantile(heatmap_data$prop_sign_scaled,.99)  
      #colorMid <- (colorMax+colorMin)*0.7 # as close as possible to Nearing
      colorMin <- -3 # like in Nearing et al, filtered
      colorMax <- 3.5 # like in Nearing et al, filtered
      colorMid <- 0 # like in Nearing et al, filtered
      
      if(length(rowOrdering)==1 && rowOrdering=="hclust"){
        desiredOrder <- orderRowsByClustering(heatmap_data,"prop_sign_scaled")
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==1 && rowOrdering=="sorted"){
        desiredOrder <- sort(unique(heatmap_data$project), decreasing = T)
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==1 && rowOrdering=="nearing"){
        OrderNearing <- c("cdi_schubert", "wood_plastic_kesy","ob_turnbaugh", "ArcticFireSoils", "edd_singh","sed_plastic_hoellein","sw_plastic_frere","seston_plastic_mccormick", "Ji_WTP_DS", "ArcticFreshwaters","GWMC_ASIA_NA", "sw_sed_detender","Chemerin","GWMC_HOT_COLD","Office","ArcticTransects","hiv_noguerajulian","cdi_vincent", "ob_zhu", "ibd_gevers", "Exercise", "Blueberry", "hiv_dinh", "ibd_papa", "glass_plastic_oberbeckmann", "ob_goodrich", "t1d_alkanani", "BISCUIT", "ob_ross", "par_scheperjans", "art_scher", "t1d_mejialeon", "asd_son", "crc_baxter", "MALL", "crc_zeller", "hiv_lozupone", "sed_plastic_rosato")
        desiredOrder <- factor(OrderNearing,levels=OrderNearing)
        heatmap_data$project <- factor(heatmap_data$project,levels=rev(desiredOrder),ordered = T)
        #heatmap_data <- bs_renameDataAccordingToNearing(heatmap_data, colName=project)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==length(unique(heatmap_data$project))){
        desiredOrder <- rowOrdering
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      
      # Clipping values of prop_sign_scaled to the range [colorMin, colorMax]
      try(heatmap_data$prop_sign_scaled <- pmin(pmax(heatmap_data$prop_sign_scaled, colorMin), colorMax))
      out <- ggplot(heatmap_data, aes(x = test, y = project, fill = prop_sign_scaled)) +
        geom_tile() +
        geom_text(aes(label = num_significant), color = "black", size = 2) +
        scale_fill_gradient2(low = "steelblue3", mid="lightyellow", high = "red2",midpoint = colorMid, limits=c(colorMin,colorMax),
                             name = "% significant [scaled]") +
        labs(x = "Differential abundance test", y = "Data set", 
             title = paste0("Significant taxa (",label,")"), subtitle = folder) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
    } 
    
    # Proportions are rank transformed
    if(plotType=="heatmapRanks"){
      if(!is.null(plotArg) && "label" %in% names(plotArg))
        label <- plotArg$label
      else
        label <- ""
      
      heatmap_data <- df %>%
        group_by(test,project) %>%
        summarise(num_significant = sum(significant,na.rm=T), 
                  prop_significant = mean(significant,na.rm=T))
      
      # ranking:
      heatmap_data <- heatmap_data %>%
        group_by(project) %>%
        mutate(prop_sign_ranks = order(prop_significant)) %>%
        ungroup()
      
      if(length(rowOrdering)==1 && rowOrdering=="hclust"){
        desiredOrder <- orderRowsByClustering(heatmap_data,"prop_sign_ranks")
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      if(length(rowOrdering)==length(unique(heatmap_data$project))){
        desiredOrder <- rowOrdering
        heatmap_data$project <- factor(heatmap_data$project,levels=desiredOrder,ordered = T)
        heatmap_data <- heatmap_data %>% arrange(project)
      }
      
      out <- ggplot(heatmap_data, aes(x = test, y = project, fill = prop_sign_ranks)) +
        geom_tile() +
        geom_text(aes(label = num_significant), color = "black", size = 2) +
        scale_fill_gradient2(low = "steelblue3", mid="lightyellow", high = "red2",midpoint = mean(c(1,length(unique(df$test)))),limits=c(1,length(unique(df$test)))) +
        labs(x = "Differential abundance test", y = "Data set", 
             title = paste0("Significant taxa (",label,")"), subtitle = folder) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
    } 
    
    if(is.null(out))
      warning("plotType obviously not found.")
    
    if(!is.null(desiredOrder))
      out$desiredOrder <- desiredOrder
    return(out)
    
  }
  
}
orderRowsByClustering <- function(heat_dat, valueCol = "prop_sign_scaled"){
  h <- heat_dat
  
  namen <- names(h)
  namen[namen==valueCol] <- "values"
  names(h) <- namen
  
  try(h <- select(h,-prop_significant),silent = T)
  try(h <- select(h,-num_significant),silent = T)
  h2 <- h %>% pivot_wider(names_from = test, values_from = values)
  
  project = h2$project
  h2 <- h2 %>% select(-project)
  h2m <- as.matrix(h2)
  row.names(h2m) <- project
  h2m[is.na(h2m)] <- 0
  
  row_clusters <- hclust(dist(h2m))
  desiredOrder <- row.names(h2m)[row_clusters$order]
  
  return(desiredOrder)
}

